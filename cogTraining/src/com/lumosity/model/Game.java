package com.lumosity.model;

import java.util.ArrayList;
import java.util.List;

import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.Record;
import com.lumosity.model.base.BaseGame;
import com.lumosity.utils.DailyKit;

/**
 * Generated by JFinal.
 */
@SuppressWarnings("serial")
public class Game extends BaseGame<Game> {
	public static final Game dao = new Game();
	int[] index3 = { 0, 8, 13, 12, 6, 2, 5, 12, 10, 15, 4, 2, 8, 15, 10, 3, 16, 15, 2, 14, 12, 12, 0, 13, 13, 6, 5,
			10, 15, 15 };
	/** 查询所有记录 **/
	public List<Game> findAll() {
		return find("select * from game");
	}

	public List<Game> findByGameClassId(int gameClassId) {
		return find("select * from game where gameClassId =?", gameClassId);
	}
	
	public List<Record> findByGameClassId2(int gameClassId) {
		return Db.find("select * from game where gameClassId =?", gameClassId);
	}

	public Game findByName(String name) {
		return findFirst("select * from game where gameFileName = ?", name);

	}

	public ArrayList<Integer> findGameIds(Long userId) {
		// 算法的输入数据：当前用户在所有游戏中的最新得分；
		// 当前用户的训练偏好和权重（每个能力的权重）；
		// 游戏配置表；
		// 相斥性矩阵
		// 能力的排列顺序为 速度 记忆 注意 灵活 逻辑
		// game_datas格式 每一行为一个游戏，游戏的数据：），

//		float[][] game_datas = { { 878, 1, 0, 5, 0, 1, 1 }, { 1760, 1, 3, 0, 1, 1, 0 }, { 718, 1, 6, 5, 1, 0, 1 },
//				{ 350, 1, 7, 0, 1, 1, 0 }, { 1422, 1, 4, 5, 1, 1, 0 }, { 555, 1, 5, 5, 1, 1, 0 },
//				{ 1009, 1, 6, 5, 1, 1, 0 }, { 266, 1, 8, 5, 1, 1, 0 }, { 1962, 1, 8, 5, 1, 1, 0 },
//				{ 311, 2, 3, 5, 1, 1, 1 }, { 978, 2, 0, 5, 1, 1, 0 }, { 747, 2, 0, 5, 0, 0, 0 },
//				{ 1963, 2, 3, 5, 1, 1, 0 }, { 871, 2, 6, 5, 1, 1, 0 }, { 418, 3, 9, 5, 1, 1, 0 },
//				{ 64, 3, 23, 5, 1, 1, 0 }, { 1165, 3, 11, 5, 1, 1, 0 }, { 1159, 3, 8, 5, 1, 1, 0 },
//				{ 1006, 3, 9, 5, 1, 1, 0 }, { 547, 4, 3, 5, 1, 1, 0 }, { 1221, 4, 6, 5, 1, 1, 0 },
//				{ 1735, 4, 5, 5, 1, 1, 0 }, { 165, 4, 5, 5, 1, 1, 0 }, { 1752, 4, 4, 5, 1, 1, 0 },
//				{ 901, 5, 3, 5, 1, 1, 0 }, { 577, 5, 2, 5, 1, 1, 0 }, { 1350, 5, 1, 5, 1, 1, 0 },
//				{ 175, 5, 0, 5, 1, 1, 0 }, { 1559, 5, 14, 5, 1, 1, 0 }, { 799, 5, 13, 5, 1, 1, 0 } };
		// 需要从数据库取得
		// 0: 最后一次分数
		// 1: 类型 1.速度 2.记忆 3.注意 4.灵活 5.逻辑
		// 2.session introduction num，保存在数据库
		// 3.已经玩了的次数， count(game_history) userid and gameId
		// 4.5.6.之前三次是否推荐了这个游戏 1:推荐 0:未推荐
//		float[][] game_datas = { { 0, 2, 0, 0, 0, 0, 0 }, { 0, 2, 2, 0, 0, 0, 0 }, { 0, 2, 3, 0, 0, 0, 0 },
//				{ 0, 2, 4, 0, 0, 0, 0 }, { 0, 2, 1, 0, 0, 0, 0 }, { 0, 3, 0, 0, 0, 0, 0 }, { 0, 3, 1, 0, 0, 0, 0 },
//				{ 0, 1, 0, 0, 0, 0, 0 }, { 0, 1, 3, 0, 0, 0, 0 }, { 0, 1, 1, 0, 0, 0, 0 }, { 0, 1, 2, 0, 0, 0, 0 },
//				{ 0, 5, 0, 0, 0, 0, 0 }, { 0, 5, 1, 0, 0, 0, 0 }, { 0, 4, 0, 0, 0, 0, 0 }, { 0, 4, 3, 0, 0, 0, 0 },
//				{ 0, 4, 2, 0, 0, 0, 0 }, { 0, 4, 1, 0, 0, 0, 0 } };
//		float[][] game_datas = { { 1153, 4, 0, 79, 1, 1, 0 }, { 1428, 2, 8, 22, 1, 1, 0 }, { 1536, 4, 13, 25, 0, 1, 1 },
//				{ 1607, 2, 12, 3, 0, 0, 1 }, { 1266, 2, 6, 30, 0, 0, 1 }, { 1502, 1, 2, 41, 1, 1, 0 },
//				{ 1595, 5, 5, 93, 1, 0, 1 }, { 1598, 4, 12, 37, 1, 1, 1 }, { 1483, 1, 10, 95, 0, 0, 0 },
//				{ 1312, 4, 15, 62, 1, 0, 1 }, { 1024, 1, 4, 62, 1, 1, 1 }, { 1377, 5, 2, 49, 1, 0, 1 },
//				{ 1064, 3, 8, 74, 0, 0, 1 }, { 1622, 5, 15, 89, 0, 1, 1 }, { 1527, 1, 10, 53, 1, 0, 0 },
//				{ 1406, 5, 3, 55, 0, 1, 1 }, { 1544, 2, 16, 8, 1, 0, 1 }, { 1394, 4, 15, 50, 0, 1, 0 },
//				{ 1060, 2, 2, 54, 1, 1, 1 }, { 1059, 1, 14, 76, 0, 0, 0 }, { 1640, 2, 12, 58, 0, 0, 0 },
//				{ 1690, 1, 12, 64, 1, 0, 1 }, { 1574, 3, 0, 72, 1, 1, 1 }, { 1023, 4, 13, 97, 1, 0, 0 },
//				{ 1278, 5, 13, 67, 0, 0, 0 }, { 1448, 3, 6, 49, 1, 0, 0 }, { 1423, 4, 5, 16, 0, 0, 1 },
//				{ 1314, 2, 10, 26, 1, 0, 1 }, { 1022, 5, 5, 1, 0, 0, 0 }, { 1505, 1, 15, 40, 1, 1, 1 } };
		
		float[][] game_datas = findGameDatas(userId);
		// 游戏兼容性矩阵 在数据库维护
		float[][] co_exist = { { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1 },
				{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
				{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
				{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
				{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 } };

		//
		int now_day = findLoginDaysByUserId(userId);// 现在是用户在平台上的第几天？ 这个要获取到的

		// 可以直接选择，在数据库维护
		float[] standard_pro = { 0.030612245f, 0.040816327f, 0.005102041f, 0.051020408f, 0.025510204f, 0.020408163f,
				0.051020408f, 0.015306122f, 0.045918367f, 0.040816327f, 0.030612245f, 0.035714286f, 0.020408163f,
				0.045918367f, 0.020408163f, 0.040816327f, 0.040816327f };

		// DB问卷数据 userId
		float[] ability_count = findAbilityCount(userId);// 每个能力选了几个
		// 这里要从数据库取，或者一开始填好问卷就转换成权重
		float[] probabilitically = null;
		float[] fp = null;
		// 看看是不是新用户
		boolean is_new = true;
		for (int i = 0; i < game_datas.length; i++) {
			if (game_datas[i][0] != 0) {
				is_new = false;
				break;
			}
		}

		fp = findFp(is_new, ability_count, standard_pro, now_day, game_datas, probabilitically);
		ArrayList<Integer> game_list = new ArrayList<Integer>();
		// c1——是否有没有玩过的游戏，获取所有的没有玩过的游戏
		// 找到最小的被玩0次的 session introduction num
		int this_game = -1;
		while (game_list.size() < 5) {
			boolean has_game_new = false;
			for (int i = 0; i < game_datas.length; i++) {
				if (game_datas[i][3] == 0 && game_datas[i][2] <= now_day) {
					has_game_new = true;
					break;
				}
			}
			int min_new_game = 0;
			if (has_game_new) {
				// has new game
				System.out.println("new");
				min_new_game = DailyKit.get_min_new_game(game_datas, now_day);
				this_game = min_new_game;
				game_list.add(this_game);
				game_datas[this_game][3]++;
			} else {
				// no new game
				System.out.println("old");
				do {
					if (this_game != -1) {
						fp[this_game] = 0;
						for (Integer gameId : game_list) {
							float gameClassId = game_datas[gameId][1];
							for (int i = 0; i < 17; i++) {
								if (game_datas[i][1] == gameClassId) {
									fp[i] = 0;
								}
							}
						}
					}
					for (float fp1 : fp) {
						System.out.print(fp1 + ",");
					}
					System.out.println();
					this_game = DailyKit.get_max_probalitically(fp);
				} while (game_list.contains(this_game));
				game_list.add(this_game);
				game_datas[this_game][3]++;
			}
			probabilitically = DailyKit.update_probabilitically(fp, co_exist, this_game);
			fp = findFp(is_new, ability_count, standard_pro, now_day, game_datas, probabilitically);
		}
		System.out.println("finish");
		return game_list;
	}

	public float[] findFp(boolean is_new, float[] ability_count, float[] standard_pro, int now_day, float[][] game_datas,float[] probabilitically) {
		float[] ability_weight = DailyKit.get_ability_weight(ability_count);
		float[] p_step_2 = null;
		float[] p_step_3 = null;
		float[] p_step_4 = null;
		float[] c_step_5 = null;
		float[] d_step_6 = null;
		float[] p_step_7 = null;
		// 概率计算
				// step1
				if (is_new) {
					// 新用户 使用常模数据中所有游戏的概率
//					System.out.println("this is a new user");
					probabilitically = standard_pro;
					now_day = 1;
					// 我这里直接用了常模概率，还没有乘以用户选择的能力的权重
					// 常模概率的计算方法 使用常模的分数，经过1，2，3，4，5，6，7，8
				} else {
					probabilitically = DailyKit.step_1(game_datas);
				}

				// step2
				p_step_2 = DailyKit.step_2(probabilitically, ability_weight, game_datas);
				// step3
				p_step_3 = DailyKit.step_3(p_step_2);
				// step4
				p_step_4 = DailyKit.get_ability_weight(p_step_3);// 操作方法与get_ability_weight一样的，所以直接用了
				// step5
				c_step_5 = DailyKit.step_5(p_step_4, now_day, game_datas);
				// step6
				d_step_6 = DailyKit.step_6(c_step_5, game_datas);
				// step7
				p_step_7 = DailyKit.step_7(d_step_6, p_step_4);
				// step8
		return DailyKit.step_8(game_datas, p_step_7);
	}
	
	/**
	 * 
	 * @param userId
	 * @return
	 */
	public float[][] findGameDatas(Long userId) {
		List<Record> gameInfos = findAllGameInfo(userId);
		List<Record> gameIds = findGameIdInPlanGame(userId);

		for (int i = 0; i < 3; i++) {
			for (Record record : gameInfos) {
				Integer gameId = record.getInt("gameId");
				if (contains(gameId, gameIds)) {
					record.set("isrecommend" + i, 1);
				} else {
					record.set("isrecommend" + i, 0);
				}
			}
		}

		int arr1 = 7;
		float gameDates[][] = new float[gameInfos.size()][arr1];
		for (int j = 0, m = gameInfos.size(); j < m; j++) {
			Record record = gameInfos.get(j);
			gameDates[j][0] = record.get("gameLPI") == null ? 0 : record.getInt("gameLPI");
			gameDates[j][1] = gameInfos.get(j).getInt("gameClassId");
			gameDates[j][2] = index3[j]; // 从数据库获取,需要新增字段
			gameDates[j][3] = gameInfos.get(j).getLong("playTimes");
			gameDates[j][4] = gameInfos.get(j).getInt("isrecommend0");
			gameDates[j][5] = gameInfos.get(j).getInt("isrecommend1");
			gameDates[j][6] = gameInfos.get(j).getInt("isrecommend2");
		}
		
		
		return gameDates;
	}

	public boolean contains(Integer gameId, List<Record> gameIds) {
		for (Record recrod : gameIds) {
			if (recrod.getInt("gameId") == gameId) {
				return true;
			}
		}
		return false;
	}

	public List<Record> findAllGameInfo(Long userId) {
		String sql = "SELECT *,COUNT(t1.gameHistoryId) playTimes FROM "
				+ "(SELECT gh.`gameHistoryId`,g.`gameId`,g.`sequence`,g.`gameName`,gh.`score`,gh.`gameLPI`, gc.`gameClassId`,gc.gameClassName"
				+ " FROM game g" + " LEFT JOIN `game_history` gh "
				+ " ON g.`gameId` = gh.`gameId` AND  gh.`userId` = ? AND gh.`score` != 0"
				+ " LEFT JOIN `game_class` gc ON g.`gameClassId` = gc.`gameClassId`" + " ORDER BY g.`sequence`"
				+ " ) AS t1" + " GROUP BY t1.`gameId`";
		List<Record> list = Db.find(sql, userId);
		return list;
	}

	public List<Record> findGameIdInPlanGame(Long userId) {
		String sql = " SELECT * FROM" + "(SELECT pg.* FROM plan_game pg "
				   + " LEFT JOIN train_plan tp ON pg.`trainPlanId` = tp.`trainPlanId` WHERE tp.`userId` = ? "
				   + ") AS t1 " 
				   + " GROUP BY t1.`gameId`  ORDER BY t1.trainPlanId DESC LIMIT 3";
		return Db.find(sql, userId);
	}

	/**
	 * 查询用户登录天数 TODO
	 * 
	 * @param userId
	 * @return
	 */
	public int findLoginDaysByUserId(Long userId) {
		return TrainPlan.dao.findDaysById(userId);
	}

	/**
	 * 查询用户注册时所填的问卷调查信息 TODO
	 * 
	 * @param userId
	 * @return
	 */
	public float[] findAbilityCount(Long userId) {
		return QuestionStatus.dao.findAbilityCount(userId);
	}
}
